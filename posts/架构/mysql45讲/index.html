<!DOCTYPE html>
<html lang="zh-cn">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>MySQL实战45讲 - 无名鼠辈</title><meta name="Description" content=""><meta property="og:title" content="MySQL实战45讲" />
<meta property="og:description" content="MySQL45讲 1. 一条SQL查询语句怎么运行的 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存的失效" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/" /><meta property="og:image" content="https://llc687.top/logo.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-28T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2021-02-28T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://llc687.top/logo.png"/>

<meta name="twitter:title" content="MySQL实战45讲"/>
<meta name="twitter:description" content="MySQL45讲 1. 一条SQL查询语句怎么运行的 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存的失效"/>
<meta name="application-name" content="无名鼠辈">
<meta name="apple-mobile-web-app-title" content="无名鼠辈"><meta name="theme-color" content="#ffffff"><meta name="msapplication-TileColor" content="#da532c"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/" /><link rel="prev" href="https://llc687.top/posts/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "MySQL实战45讲",
        "inLanguage": "zh-cn",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "https:\/\/llc687.top\/posts\/%E6%9E%B6%E6%9E%84\/mysql45%E8%AE%B2\/"
        },"genre": "posts","keywords": "MySQL, 数据库","wordcount":  12833 ,
        "url": "https:\/\/llc687.top\/posts\/%E6%9E%B6%E6%9E%84\/mysql45%E8%AE%B2\/","datePublished": "2021-02-28T00:00:00+00:00","dateModified": "2021-02-28T00:00:00+00:00","publisher": {
            "@type": "Organization",
            "name": "Lyf"},"author": {
                "@type": "Person",
                "name": "Lyf"
            },"description": ""
    }
    </script></head>
    <body header-desktop="fixed" header-mobile="auto"><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="无名鼠辈"><span id="id-1" class="typeit"></span></a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 归档 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><a class="menu-item" href="/about/"> 关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id="search-desktop">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-desktop">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-desktop" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-desktop" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-desktop">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="无名鼠辈"><span id="id-2" class="typeit"></span></a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><div class="search-wrapper">
                    <div class="search mobile" id="search-mobile">
                        <input type="text" placeholder="搜索文章标题或内容..." id="search-input-mobile">
                        <a href="javascript:void(0);" class="search-button search-toggle" id="search-toggle-mobile" title="搜索">
                            <i class="fas fa-search fa-fw"></i>
                        </a>
                        <a href="javascript:void(0);" class="search-button search-clear" id="search-clear-mobile" title="清空">
                            <i class="fas fa-times-circle fa-fw"></i>
                        </a>
                        <span class="search-button search-loading" id="search-loading-mobile">
                            <i class="fas fa-spinner fa-fw fa-spin"></i>
                        </span>
                    </div>
                    <a href="javascript:void(0);" class="search-cancel" id="search-cancel-mobile">
                        取消
                    </a>
                </div><a class="menu-item" href="/posts/" title="">归档</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a class="menu-item" href="/about/" title="">关于</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">MySQL实战45讲</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="/" title="Author" rel=" author" class="author"><i class="fas fa-user-circle fa-fw"></i>Lyf</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><i class="far fa-folder fa-fw"></i>数据库</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-02-28">2021-02-28</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 12833 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 26 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#1-一条sql查询语句怎么运行的">1. 一条SQL查询语句怎么运行的</a></li>
        <li><a href="#2-一条sql更新语句怎么运行">2. 一条SQL更新语句怎么运行</a>
          <ul>
            <li><a href="#redo-log粉板">redo log（粉板）</a></li>
            <li><a href="#binlog">binlog</a></li>
            <li><a href="#undolog">undolog</a></li>
          </ul>
        </li>
        <li><a href="#3事务隔离">3.事务隔离</a></li>
        <li><a href="#4-5-索引">4-5. 索引</a></li>
        <li><a href="#6-全局锁和表锁">6. 全局锁和表锁</a></li>
        <li><a href="#7行锁">7.行锁</a>
          <ul>
            <li><a href="#两阶段锁">两阶段锁</a></li>
            <li><a href="#死锁">死锁</a></li>
          </ul>
        </li>
        <li><a href="#8-事务到底是不是隔离的">8. 事务到底是不是隔离的</a></li>
        <li><a href="#9普通索引和唯一索引">9.普通索引和唯一索引</a>
          <ul>
            <li><a href="#查询">查询</a></li>
            <li><a href="#更新">更新</a></li>
          </ul>
        </li>
        <li><a href="#10-mysql为什么会选错索引">10. mysql为什么会选错索引</a></li>
        <li><a href="#11-怎么给字符串字段加索引">11. 怎么给字符串字段加索引</a></li>
        <li><a href="#12为什么我的mysql会抖一下">12.为什么我的Mysql会抖一下</a>
          <ul>
            <li><a href="#121-什么情况会引发数据库的-flush-过程呢掌柜在什么情况下会把粉板上的赊账记录改到账本上">12.1 什么情况会引发数据库的 flush 过程呢？掌柜在什么情况下会把粉板上的赊账记录改到账本上？</a></li>
          </ul>
        </li>
        <li><a href="#13-为什么表数据删一半表文件大小不变">13. 为什么表数据删一半，表文件大小不变</a>
          <ul>
            <li>
              <ul>
                <li><a href="#参数-innodb_file_per_table">参数 innodb_file_per_table</a></li>
                <li><a href="#删除数据">删除数据</a></li>
                <li><a href="#数据空洞">数据空洞</a></li>
                <li><a href="#重建表">重建表</a></li>
                <li><a href="#online与inplace与copy-table-online-ddlhttpswwwcnblogscomxinysup6732646html">Online与inplace与copy table <a href="https://www.cnblogs.com/xinysu/p/6732646.html">Online DDL</a></a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#14-count这么慢我该怎么办">14. count(*)这么慢，我该怎么办</a></li>
        <li><a href="#16-order-by是怎么工作的">16. “order by”是怎么工作的</a>
          <ul>
            <li>
              <ul>
                <li><a href="#sort_buffer_size">sort_buffer_size</a></li>
                <li><a href="#全字段排序">全字段排序</a></li>
                <li><a href="#rowid-排序">rowid 排序</a></li>
                <li><a href="#覆盖索引">覆盖索引</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#17如何正确的显示随机消息">17.如何正确的显示随机消息</a>
          <ul>
            <li>
              <ul>
                <li><a href="#随机排序算法">随机排序算法</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#18-为什么这些sql语句逻辑相同性能却差异巨大">18. 为什么这些SQL语句逻辑相同，性能却差异巨大？</a></li>
        <li><a href="#19-为什么我只查了一行也这么慢">19 .为什么我只查了一行，也这么慢</a>
          <ul>
            <li>
              <ul>
                <li><a href="#等mdl锁">等MDL锁</a></li>
                <li><a href="#等flush">等flush</a></li>
                <li><a href="#等行锁">等行锁</a></li>
                <li><a href="#查询慢">查询慢</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#20-幻读是什么幻读有什么问题">20. 幻读是什么，幻读有什么问题</a>
          <ul>
            <li>
              <ul>
                <li><a href="#201-幻读的问题">20.1 幻读的问题</a></li>
                <li><a href="#202-如何解决幻读">20.2 如何解决幻读</a></li>
                <li><a href="#203-间隙锁带来的问题">20.3 间隙锁带来的问题</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li><a href="#21-为什么我只改一行的语句锁这么多">21. 为什么我只改一行的语句，锁这么多</a></li>
        <li><a href="#22-mysql有哪些饮鸩止渴提高性能的方法">22. MySQL有哪些“饮鸩止渴”提高性能的方法</a>
          <ul>
            <li><a href="#短连接风暴">短连接风暴</a></li>
            <li><a href="#慢查询性能问题">慢查询性能问题</a></li>
            <li><a href="#qps-突增问题">QPS 突增问题</a></li>
          </ul>
        </li>
        <li><a href="#23mysql如何保证数据不丢">23.Mysql如何保证数据不丢</a>
          <ul>
            <li><a href="#binlog-的写入机制">binlog 的写入机制</a></li>
            <li><a href="#redo-log-的写入机制">redo log 的写入机制</a></li>
            <li><a href="#io性能瓶颈">IO性能瓶颈</a></li>
          </ul>
        </li>
        <li><a href="#24-mysql是怎么保证主备一致的">24. MySQL是怎么保证主备一致的</a></li>
        <li><a href="#25-mysql-如何保证高可用">25. Mysql 如何保证高可用</a></li>
        <li><a href="#26-备库为什么延迟几个小时">26. 备库为什么延迟几个小时</a></li>
        <li><a href="#27-主库出问题了从库怎么办">27. 主库出问题了，从库怎么办？</a></li>
        <li><a href="#28-读写分离有哪些坑">28. 读写分离有哪些坑？</a></li>
        <li><a href="#29丨如何判断一个数据库是不是出问题了">29丨如何判断一个数据库是不是出问题了？</a></li>
        <li><a href="#31丨误删数据后除了跑路还能怎么办">31丨误删数据后除了跑路，还能怎么办？</a>
          <ul>
            <li><a href="#误删行">误删行</a></li>
            <li><a href="#误删库--表">误删库 / 表</a></li>
          </ul>
        </li>
        <li><a href="#32丨为什么还有kill不掉的语句">32丨为什么还有kill不掉的语句？</a></li>
        <li><a href="#33丨我查这么多数据会不会把数据库内存打爆">33丨我查这么多数据，会不会把数据库内存打爆？</a></li>
        <li><a href="#34丨到底可不可以使用join">34丨到底可不可以使用join？</a>
          <ul>
            <li><a href="#join-的流程">Join 的流程</a></li>
            <li><a href="#驱动表">驱动表</a></li>
          </ul>
        </li>
        <li><a href="#35--join语句怎么优化">35 | join语句怎么优化？</a>
          <ul>
            <li><a href="#multi-range-read-优化">Multi-Range Read 优化</a></li>
            <li><a href="#batched-key-access">Batched Key Access</a></li>
            <li><a href="#bnl-转-bka">BNL 转 BKA</a></li>
            <li><a href="#hash-join">hash join</a></li>
          </ul>
        </li>
        <li><a href="#36--为什么临时表可以重名">36 | 为什么临时表可以重名？</a>
          <ul>
            <li><a href="#用途">用途</a></li>
            <li><a href="#重名">重名</a></li>
            <li><a href="#主从同步">主从同步</a></li>
          </ul>
        </li>
        <li><a href="#37--什么时候会使用内部临时表">37 | 什么时候会使用内部临时表？</a></li>
        <li><a href="#38都说innodb好那还要不要使用memory引擎">38.都说InnoDB好，那还要不要使用Memory引擎？</a>
          <ul>
            <li><a href="#数据组织结构">数据组织结构</a></li>
            <li><a href="#hash-索引和-b-tree-索引">hash 索引和 B-Tree 索引</a></li>
            <li><a href="#锁">锁</a></li>
            <li><a href="#持久性">持久性</a></li>
          </ul>
        </li>
        <li><a href="#39-自增主键为什么不是连续的">39. 自增主键为什么不是连续的？</a>
          <ul>
            <li><a href="#新插入">新插入</a></li>
            <li><a href="#导致不连续">导致不连续</a></li>
          </ul>
        </li>
        <li><a href="#40-insert语句的锁为什么这么多">40.  insert语句的锁为什么这么多？</a></li>
        <li><a href="#41-怎么最快地复制一张表">41. 怎么最快地复制一张表？</a>
          <ul>
            <li><a href="#mysqldump-方法">mysqldump 方法</a></li>
            <li><a href="#导出-csv-文件">导出 CSV 文件</a></li>
            <li><a href="#物理拷贝">物理拷贝</a></li>
          </ul>
        </li>
        <li><a href="#42grant之后要跟着flush-privileges吗">42.grant之后要跟着flush privileges吗？</a></li>
        <li><a href="#43要不要使用分区表">43.要不要使用分区表？</a></li>
        <li><a href="#45-自增id用完了咋办">45. 自增id用完了咋办</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="mysql45讲">MySQL45讲</h1>
<h3 id="1-一条sql查询语句怎么运行的">1. 一条SQL查询语句怎么运行的</h3>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84.png"
        data-srcset="https://img.llc687.top/uPic/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84.png, https://img.llc687.top/uPic/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84.png 1.5x, https://img.llc687.top/uPic/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84.png"
        title="https://img.llc687.top/uPic/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%80%8E%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84.png" /></p>
<p><strong>但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。</strong></p>
<ul>
<li>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。</li>
</ul>
<h3 id="2-一条sql更新语句怎么运行">2. 一条SQL更新语句怎么运行</h3>
<p>MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。</p>
<h4 id="redo-log粉板">redo log（粉板）</h4>
<p>当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（里面，并更新内存，这个时候更新就算完成了。在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。</p>
<ul>
<li>大小固定，循环写</li>
<li><strong>crash-safe</strong></li>
</ul>
<h4 id="binlog">binlog</h4>
<ul>
<li>redo log 是innoDB引擎特有的，server 层的叫 binlog(归档日志)</li>
<li>redolog 是物理日志，记录“在某个数据页上做了什么修改”；binlog 是逻辑日志，是语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”</li>
<li>redolog循环写，binlog追加</li>
</ul>
<p>对于语句 <code>update T set c=c+1 where ID=2;</code></p>
<ol>
<li>执行器先找引擎取 ID=2 这一行。ID 是主键，直接用树搜索找到。如果 ID=2 这一行所在数据页就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>
<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成</li>
</ol>
<p>对于redo log 是有两阶段的：commit 和 prepare</p>
<p>如果不使用“两阶段提交”，数据库的状态就有可能和用它的日志恢复出来的库的状态不一致.</p>
<ul>
<li>先r后b:binlog丢失，少了一次更新，恢复后仍是0。</li>
<li>先b后r:多了一次事务，恢复后是1.</li>
</ul>
<h4 id="undolog">undolog</h4>
<p>Undo log的存在保证了事务的<strong>原子性</strong>，MVCC就是依赖它来实现，当对任何行做了修改的时候都会在<code>undo log</code>里面记录，大量的undo log构成行的历史版本记录，在需要的时候可以回退(rollback)到任何版本；</p>
<h3 id="3事务隔离">3.事务隔离</h3>
<p>ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</p>
<p>SQL标准隔离级别：</p>
<ul>
<li>读未提交: 一个事务还没提交时，它做的变更就能被别的事务看到。</li>
<li>读提交: 一个事务提交之后，它做的变更才会被其他事务看到。</li>
<li>可重复读: 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li>
<li>串行化: 顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行</li>
</ul>
<p>避免使用长事务，set autocommit=1, 通过显式语句的方式来启动事务。</p>
<p>information_schema 库的 innodb_trx 中可以查询长事务。</p>
<h3 id="4-5-索引">4-5. 索引</h3>
<p>基于B+树。</p>
<ul>
<li>主键索引的叶子节点存的是整行数据。 InnoDB 里，也被称为聚簇索引（clustered index）。</li>
<li>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引。</li>
<li>非主键索引查询会回表。</li>
<li>自增id可以避免维护B+树时的分裂、合并问题。</li>
</ul>
<p>索引维护。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-30%e4%b8%8b%e5%8d%885.55.22.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-30%e4%b8%8b%e5%8d%885.55.22.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-30%e4%b8%8b%e5%8d%885.55.22.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-30%e4%b8%8b%e5%8d%885.55.22.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-03-30下午5.55.22.png"
        title="https://img.llc687.top/uPic/截屏2020-03-30下午5.55.22.png" /></p>
<ul>
<li>B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行 ID 值为 700，则只需要在 R5 的记录后面插入一个新记录。如果新插入的 ID 值为 400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</li>
<li>更糟情况是，如果 R5 所在的数据页已经满了，根据 B+ 树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。在这种情况下，性能自然会受影响。</li>
<li>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</li>
<li>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</li>
</ul>
<p>覆盖索引</p>
<ul>
<li>即：where 非主键查询，但只查询ID,ID在非主键索引树上了，不需要回表。</li>
</ul>
<p>联合索引</p>
<ul>
<li>最左前缀</li>
</ul>
<p>索引下推</p>
<ul>
<li>对于where 条件，如果索引中包含了该字段信息，会直接进行过滤，不会再回表比对。</li>
</ul>
<h3 id="6-全局锁和表锁">6. 全局锁和表锁</h3>
<p><strong>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</strong></p>
<ol>
<li><strong>全局锁的典型使用场景是，做全库逻辑备份</strong></li>
</ol>
<ul>
<li>Flush tables with read lock (FTWRL)：其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</li>
<li>相较于readOnly,本命令在客户端异常后会自动释放锁。</li>
</ul>
<ol start="2">
<li>表级锁（表锁和数据锁）
<strong>表锁的语法是 lock tables … read/write</strong>
<strong>另一类表级的锁是 MDL（metadata lock)</strong>。在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，自动加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。
<ul>
<li>读写锁、写锁之间互斥</li>
</ul>
</li>
</ol>
<p>MDL会导致该表结构时阻塞，online DDL可以看下。</p>
<h3 id="7行锁">7.行锁</h3>
<p>MySQL 的行锁是在引擎层由各个引擎自己实现的。MyISAM 不支持行锁。不支持行锁意味着并发控制只能使用表锁，同张表上只能有一个更新在执行，这就会影响到业务并发度。</p>
<h4 id="两阶段锁">两阶段锁</h4>
<p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<ul>
<li>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</li>
</ul>
<h4 id="死锁">死锁</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/7rTPNL.png"
        data-srcset="https://img.llc687.top/uPic/7rTPNL.png, https://img.llc687.top/uPic/7rTPNL.png 1.5x, https://img.llc687.top/uPic/7rTPNL.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/7rTPNL.png"
        title="https://img.llc687.top/uPic/7rTPNL.png" /></p>
<p>这样就互相等待了。（1互斥、占有且等待、不可剥夺、循环等待）</p>
<p>死锁后：</p>
<ul>
<li>等待，设置超时时间</li>
<li>死锁检测，主动回滚某个事务（推荐且默认）。
<ul>
<li>但并发过多时，死锁检测耗费CPU过多。
<ul>
<li>保证不出现，关闭检测。</li>
<li>控制并发度</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="8-事务到底是不是隔离的">8. 事务到底是不是隔离的</h3>
<ul>
<li>begin/start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。</li>
<li>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</li>
<li>数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2019-12-22%e4%b8%8b%e5%8d%885.00.28.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2019-12-22%e4%b8%8b%e5%8d%885.00.28.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2019-12-22%e4%b8%8b%e5%8d%885.00.28.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2019-12-22%e4%b8%8b%e5%8d%885.00.28.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2019-12-22下午5.00.28.png"
        title="https://img.llc687.top/uPic/截屏2019-12-22下午5.00.28.png" /></p>
<pre><code>        三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，每次需要时根据当前版本和 undo log 计算的。如需要 V2时，就通过 V4 依次执行 U3、U2 算出来。
</code></pre>
<ul>
<li>InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%885.02.57.png"
        data-srcset="https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%885.02.57.png, https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%885.02.57.png 1.5x, https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%885.02.57.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%885.02.57.png"
        title="https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2019-12-22%E4%B8%8B%E5%8D%885.02.57.png" /></p>
<pre><code>    绿色可见，红色不可见。黄色中，如果在数组中，是未提交的事务生成的，不可见。否则可见。


	**InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。**
</code></pre>
<ul>
<li><strong>更新数据都是先读后写的，而这个读，只能读当前的值，称为“当前读”（current read）</strong></li>
<li>对于可重复读，查询只承认在事务启动前就已经提交完成的数据；</li>
<li>对于读提交，查询只承认在语句启动前就已经提交完成的数据；</li>
</ul>
<h3 id="9普通索引和唯一索引">9.普通索引和唯一索引</h3>
<h4 id="查询">查询</h4>
<ul>
<li>对于普通索引查第一个记录后还要查下一个，直到不满足。唯一索引直接定位。但差距很小，innoDb按数据页读写，16KB在内存。</li>
</ul>
<h4 id="更新">更新</h4>
<ul>
<li>更新一个数据页时，如果数据页在内存中就直接更新。不在，将更新操作缓存在 change buffer 中，不需从磁盘中读入了。在下次查询要访问这个数据页时，将数据页读入内存，然后执行 change buffer 中与这个页有关的操作。
<ul>
<li>change buffer 在内存中有拷贝，也会被写入到磁盘上。</li>
<li>将 change buffer 中的操作应用到原数据页，得到最新结果的过程为 merge。除访问数据页会触发 merge ，后台线程会定期 merge。在数据库正常关闭（shutdown）的过程中，也会 merge 。</li>
</ul>
</li>
<li>唯一索引需要判断唯一性约束，必须读入数据页，也就直接写了，不需要change buffer。</li>
<li>普通索引就可以先写入change buffer,避免io开销。</li>
</ul>
<p>那么对于读少写多，change buffer就有用。反过来还是要多次io,效益降低。</p>
<h3 id="10-mysql为什么会选错索引">10. mysql为什么会选错索引</h3>
<ul>
<li>索引信息统计不准确的，可以使用 <code>analyze table x</code>重新分析。</li>
<li>优化器误判的，可以 <code>force index</code>强制指定。
<ul>
<li>或者修改语句引导优化器，增加/删除索引绕过。</li>
</ul>
</li>
</ul>
<h3 id="11-怎么给字符串字段加索引">11. 怎么给字符串字段加索引</h3>
<ul>
<li><strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></li>
<li>使用前缀索引可能就用不上覆盖索引对查询性能的优化了。</li>
<li>倒序存储，再创建前缀索引，用于绕过字符串本身前缀的区分度不够的问题；</li>
<li>创建 hash 字段索引，查询性能稳定，有额外的存储和计算消耗，跟第三种方式一样，都不支持范围扫描。</li>
</ul>
<h3 id="12为什么我的mysql会抖一下">12.为什么我的Mysql会抖一下</h3>
<ul>
<li><strong>当内存数据页跟磁盘数据页内容不一致的时候，我们称这个内存页为“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，称为“干净页”</strong>。
<ul>
<li>平时执行很快的更新操作，其实就是在写内存和日志，而 MySQL 偶尔“抖”一下的那个瞬间，可能就是在刷脏页（flush）。</li>
</ul>
</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%889.46.27.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%889.46.27.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%889.46.27.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%889.46.27.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-01-12下午9.46.27.png"
        title="https://img.llc687.top/uPic/截屏2020-01-12下午9.46.27.png" /></p>
<h4 id="121-什么情况会引发数据库的-flush-过程呢掌柜在什么情况下会把粉板上的赊账记录改到账本上">12.1 什么情况会引发数据库的 flush 过程呢？掌柜在什么情况下会把粉板上的赊账记录改到账本上？</h4>
<ul>
<li>粉板满了记不下。 InnoDB 的 redo log 写满。会停止所有更新，checkpoint往前推，redo log 留出空间继续写。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%889.57.16.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%889.57.16.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%889.57.16.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%889.57.16.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-01-12下午9.57.16.png"
        title="https://img.llc687.top/uPic/截屏2020-01-12下午9.57.16.png" /></p>
<ul>
<li>生意太好，要记的太多，快记不住了，赶紧找账本把这笔账先加进去。<strong>系统内存不足</strong></li>
<li>生意不忙了空闲时。其实即使是“生意好”时，也要见缝插针地有机会就刷一点“脏页”。</li>
<li>年底关门清账。Mysql正常关闭。</li>
</ul>
<p>这四种情况，三、四不需考虑，本来就是要空闲或关门的。</p>
<ul>
<li>第一种InnoDb要尽量避免。出现这种情况时，整个系统就不能再接受更新了，所有更新都必须堵住。从监控上看，这时候更新数会跌为 0。</li>
<li>第二种则是常态，<strong>InnoDB 用缓冲池（buffer pool）管理内存，缓冲池中的内存页有三种状态：</strong>
<ul>
<li>第一种是，还没有使用的；</li>
<li>第二种是，使用了并且是干净页；</li>
<li>第三种是，使用了并且是脏页。</li>
</ul>
</li>
</ul>
<p>因读数据要读到内存页，干净页直接用，脏页就要先刷入磁盘，干净后用。那么以下两种情况就会明显影响性能。</p>
<ul>
<li>个查询要淘汰的脏页个数太多，会导致查询的响应时间明显变长；</li>
<li>日志写满，更新全部堵住，写性能跌为 0，这种情况对敏感业务来说，是不能接受的。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%8810.09.36.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%8810.09.36.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%8810.09.36.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-01-12%e4%b8%8b%e5%8d%8810.09.36.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-01-12下午10.09.36.png"
        title="https://img.llc687.top/uPic/截屏2020-01-12下午10.09.36.png" /></p>
<p>要避免的话，首先要合理地设置 innodb_io_capacity 的值，还要<strong>多关注脏页比例，不要让它经常接近 75%</strong>。</p>
<h3 id="13-为什么表数据删一半表文件大小不变">13. 为什么表数据删一半，表文件大小不变</h3>
<h5 id="参数-innodb_file_per_table">参数 innodb_file_per_table</h5>
<p>表数据既可存在共享表空间里，也可是单独的文件。</p>
<ol>
<li>参数为 OFF 表示的是，表数据放在系统共享表空间，跟数据字典放一起；</li>
<li>ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</li>
</ol>
<p>从 MySQL 5.6.6 开始，默认值就是 ON 。设置为 ON，是推荐做法。</p>
<h5 id="删除数据">删除数据</h5>
<p>删掉一个 400 记录，InnoDB 记录标记为删除。如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但磁盘文件大小并不会缩小。</p>
<p>如果删掉了一个数据页上的所有记录，整个数据页就可以被复用了。</p>
<p>这样就会造成空洞。</p>
<h5 id="数据空洞">数据空洞</h5>
<p><strong>不止是删除数据会造成空洞，插入数据也会。</strong></p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/eoHzwl.jpg"
        data-srcset="https://img.llc687.top/uPic/eoHzwl.jpg, https://img.llc687.top/uPic/eoHzwl.jpg 1.5x, https://img.llc687.top/uPic/eoHzwl.jpg 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/eoHzwl.jpg"
        title="https://img.llc687.top/uPic/eoHzwl.jpg" /></p>
<p>PageA满了，新增就会开辟PageB。</p>
<h5 id="重建表">重建表</h5>
<p>去除上述情况造成的空洞，可以使用<code>alter table A engine=InnoDB</code>来重建，但不是OnLine的，执行阶段不能更新。</p>
<p><strong>MySQL 5.6 版本开始引入的 Online DDL，对这个操作流程做了优化。</strong></p>
<ul>
<li>对于过程中的更新，会将操作记录在一个日志文件（row log）中，临时文件生成后会重放。</li>
</ul>
<p><strong>alter 语句在启动的时候需要获取 MDL 写锁</strong>。但是这个写锁在真正拷贝数据之前就退化成读锁了。</p>
<p>因为要实现 Online，MDL 读锁不会阻塞增删改操作。不干脆直接解锁是为了保护自己，禁止其他线程对这个表同时做 DDL。</p>
<h5 id="online与inplace与copy-table-online-ddlhttpswwwcnblogscomxinysup6732646html">Online与inplace与copy table <a href="https://www.cnblogs.com/xinysu/p/6732646.html" target="_blank" rel="noopener noreffer">Online DDL</a></h5>
<p>Innodb早期支持通过copy table跟inplace的方式来执行DDL语句.</p>
<ul>
<li>inplace在copy table的基础上不需copy整个表格，只需在原来ibd文件上，新建所需要的索引页.节约极大IO资源占用. 且速度提高，减少了该表不提供写服务时长。但inplace仅支持索引的创建和删除，不支持其他的DDL操作。</li>
</ul>
<p>DDL 过程如果是 Online 的，就一定是 inplace 的；</p>
<p>反过来未必，也就是说 inplace 的 DDL，有可能不是 Online 的。截止到 MySQL 8.0，添加全文索引（FULLTEXT index）和空间索引 (SPATIAL index) 就属于这种情况。</p>
<h3 id="14-count这么慢我该怎么办">14. count(*)这么慢，我该怎么办</h3>
<p>在不同的 MySQL 引擎中，count(*) 有不同的实现方式。</p>
<ul>
<li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高；</li>
<li>而 InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li>
</ul>
<p>InnoDB 是索引组织表，普通索引树比主键索引树小很多。对于 count(*) 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。<strong>在保证逻辑正确的前提下，尽量减少扫描的数据量，是数据库系统设计的通用法则之一。</strong></p>
<p><strong>对于 count(主键 id) 来说</strong>，InnoDB 引擎会遍历整表，把每一行 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p>
<p><strong>对于 count(1) 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p>
<p><strong>对于 count(字段) 来说</strong>：</p>
<ol>
<li>如果这个“字段”是定义 not null ，一行行从记录里面读出这个字段，判断不能为 null，按行累加；</li>
<li>如果这个“字段”定义允许 null，执行时，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。</li>
</ol>
<p><strong>但是 count(*) 是例外</strong>，不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加。</p>
<p>**按照效率排序的话，count(字段)&lt;count(主键 id)&lt;count(1)≈count(<em>) 。</em></p>
<h3 id="16-order-by是怎么工作的">16. “order by”是怎么工作的</h3>
<h5 id="sort_buffer_size">sort_buffer_size</h5>
<p>就是 MySQL 为排序开辟的内存（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p>
<h5 id="全字段排序">全字段排序</h5>
<p>如果 MySQL 认为内存足够大，会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p>
<h5 id="rowid-排序">rowid 排序</h5>
<p>MySQL 实在是担心排序内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p>
<p>这也就体现了 MySQL 的一个设计思想：<strong>如果内存够，就要多利用内存，尽量减少磁盘访问。</strong></p>
<h5 id="覆盖索引">覆盖索引</h5>
<p>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</p>
<h3 id="17如何正确的显示随机消息">17.如何正确的显示随机消息</h3>
<p><strong>order by rand() 使用了内存临时表，内存临时表排序的时候使用了 rowid 排序方法。</strong></p>
<ul>
<li>对于没有主键的 InnoDB 表来说，这个 rowid 就是由系统生成的；</li>
<li>tmp_table_size 这个配置限制了内存临时表的大小。不够就使用磁盘临时表。</li>
<li>不论如何，该语句都会扫描大量行数，且排序过程浪费大量资源。</li>
</ul>
<h5 id="随机排序算法">随机排序算法</h5>
<ol>
<li>取得这个表的主键 id 的最大值 M 和最小值 N;</li>
<li>用随机函数生成一个最大值到最小值之间的数 X = (M-N)*rand() + N;</li>
<li>取不小于 X 的第一个 ID 的行。</li>
</ol>
<p>这样id有空洞的话，不同行概率不同。</p>
<ol>
<li>取得整个表的行数，并记为 C。</li>
<li>取得 Y = floor(C * rand())。 floor 函数在这里的作用，就是取整数部分。</li>
<li>再用 limit Y,1 取得一行。</li>
</ol>
<p>解决了数据空洞，但limit 开销较大。（也比order by rand()好）</p>
<h3 id="18-为什么这些sql语句逻辑相同性能却差异巨大">18. 为什么这些SQL语句逻辑相同，性能却差异巨大？</h3>
<ul>
<li>**对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。**而只能使用全索引扫描.
<ul>
<li>对于传入的值在B+树中无法检索。</li>
</ul>
</li>
<li>隐式类型转换.类型转换不会使用索引。</li>
<li>隐式字符编码转换</li>
</ul>
<p>以上实际都是<strong>在对索引字段做函数操作</strong></p>
<h3 id="19-为什么我只查了一行也这么慢">19 .为什么我只查了一行，也这么慢</h3>
<h5 id="等mdl锁">等MDL锁</h5>
<p><code>show processlist</code>命令查看时：Waiting for table metadata lock</p>
<p>某语句拿MDL写锁阻塞MDL读锁。<code>sys.schema_table_lock_waits</code>可查看造成阻塞的process id。</p>
<h5 id="等flush">等flush</h5>
<p><code>show processlist</code>命令查看时：Waiting for table flus</p>
<p>flush很快，出现该状态可能是：有个 flush tables 命令被别的语句堵住，然后它又堵住 select 语句。</p>
<h5 id="等行锁">等行锁</h5>
<p>某事物持有写锁未提交。<code>sys.innodb_lock_waits</code>可查询谁在占用写锁。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.33.31.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.33.31.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.33.31.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.33.31.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-03-15下午5.33.31.png"
        title="https://img.llc687.top/uPic/截屏2020-03-15下午5.33.31.png" /></p>
<h5 id="查询慢">查询慢</h5>
<p>当事物A开始事务，事务B开始执行大量更新。select是当前读，就需要依次执行undo log。找到事务B开始前的值。</p>
<h3 id="20-幻读是什么幻读有什么问题">20. 幻读是什么，幻读有什么问题</h3>
<p>幻读：是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没看到的行。</p>
<ul>
<li>可重复读隔离级别下，普通查询是快照读，不会看到别的事务插入的数据的。幻读在“当前读”下才会出现。</li>
<li>幻读仅专指“新插入的行”。修改原有数据导致的查询多了一条不算幻读。</li>
</ul>
<h5 id="201-幻读的问题">20.1 幻读的问题</h5>
<p><strong>语义上</strong>： 事务A的select for update的“我要把xxx的行锁住，不允许读写”。就被破坏了。</p>
<p><strong>数据一致性</strong>：</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.50.20.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.50.20.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.50.20.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.50.20.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-03-15下午5.50.20.png"
        title="https://img.llc687.top/uPic/截屏2020-03-15下午5.50.20.png" /></p>
<p>执行完成后数据是：(0,5,5)、(1,5,5)、(5,5,100)。数据没问题。</p>
<p>但binlog有问题：<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.51.39.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.51.39.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.51.39.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%885.51.39.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-03-15下午5.51.39.png"
        title="https://img.llc687.top/uPic/截屏2020-03-15下午5.51.39.png" /></p>
<p>如果拿这个binlog去备库、克隆。得到的是 (0,5,100)、(1,5,100) 和 (5,5,100)。</p>
<p><strong>即使把所有的记录都加上锁，还是阻止不了新插入的记录。新的未被锁。</strong></p>
<h5 id="202-如何解决幻读">20.2 如何解决幻读</h5>
<p>产生幻读的原因是行锁只能锁住行，但是新插入记录这个动作，要更新的是记录之间的“间隙”。所以加入间隙锁。</p>
<p><strong>跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作</strong>。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%886.01.06.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%886.01.06.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%886.01.06.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-03-15%e4%b8%8b%e5%8d%886.01.06.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-03-15下午6.01.06.png"
        title="https://img.llc687.top/uPic/截屏2020-03-15下午6.01.06.png" /></p>
<p><strong>间隙锁和行锁合称 next-key lock，每个 next-key lock 是前开后闭区间。</strong></p>
<h5 id="203-间隙锁带来的问题">20.3 间隙锁带来的问题</h5>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2020-03-15%E4%B8%8B%E5%8D%886.04.26.png"
        data-srcset="https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2020-03-15%E4%B8%8B%E5%8D%886.04.26.png, https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2020-03-15%E4%B8%8B%E5%8D%886.04.26.png 1.5x, https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2020-03-15%E4%B8%8B%E5%8D%886.04.26.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2020-03-15%E4%B8%8B%E5%8D%886.04.26.png"
        title="https://img.llc687.top/uPic/%E6%88%AA%E5%B1%8F2020-03-15%E4%B8%8B%E5%8D%886.04.26.png" /></p>
<p><strong>间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的。</strong></p>
<h3 id="21-为什么我只改一行的语句锁这么多">21. 为什么我只改一行的语句，锁这么多</h3>
<p><strong>加锁规则里面，包含了两个“原则”、两个“优化”和一个“bug”。</strong></p>
<ol>
<li>原则 1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</li>
<li>原则 2：查找过程中访问到的对象才会加锁。</li>
<li>优化 1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</li>
<li>优化 2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</li>
<li>一个 bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
<h3 id="22-mysql有哪些饮鸩止渴提高性能的方法">22. MySQL有哪些“饮鸩止渴”提高性能的方法</h3>
<h4 id="短连接风暴">短连接风暴</h4>
<p>使用短连接在业务高峰时期，可能出现连接数暴涨。</p>
<p><strong>第一种方法：先处理掉那些占着连接但是不工作的线程。</strong></p>
<p><strong>第二种方法：减少连接过程的消耗。</strong></p>
<h4 id="慢查询性能问题">慢查询性能问题</h4>
<p><strong>慢查询的第一种可能是，索引没有设计好。</strong></p>
<p><strong>慢查询的第二种可能是，语句没写好。</strong></p>
<ul>
<li>query_rewrite 存储过程临时转换语句</li>
</ul>
<p><strong>慢查询的第三种可能是，MySQL 选错了索引。</strong></p>
<ul>
<li>force index</li>
</ul>
<h4 id="qps-突增问题">QPS 突增问题</h4>
<ul>
<li>白名单去掉</li>
<li>限制语句</li>
<li>删除用户</li>
</ul>
<h3 id="23mysql如何保证数据不丢">23.Mysql如何保证数据不丢</h3>
<h4 id="binlog-的写入机制">binlog 的写入机制</h4>
<p>事务执行中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<p>每个线程有自己 binlog cache，但是共用同一份 binlog 文件。</p>
<p>write(写入 page cache) 和 fsync 的时机，是由参数 sync_binlog 控制的：N次write后才会fsync</p>
<h4 id="redo-log-的写入机制">redo log 的写入机制</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%885.40.43.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%885.40.43.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%885.40.43.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%885.40.43.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-04-06下午5.40.43.png"
        title="https://img.llc687.top/uPic/截屏2020-04-06下午5.40.43.png" /></p>
<ol>
<li>存在 redo log buffer 中，物理上是在 MySQL 进程内存中，就是图中的红色部分；</li>
<li>写到磁盘 (write)，但是没有持久化（fsync)，物理上是在文件系统的 page cache 里面，也就是图中的黄色部分；</li>
<li>持久化到磁盘，对应的是 hard disk，也就是图中的绿色部分。</li>
</ol>
<p>为控制 redo log 的写入策略，提供了 innodb_flush_log_at_trx_commit 参数，有三种可能取值：</p>
<ol>
<li>0 时，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>1 时，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>2 时，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
<p>除了后台线程每秒一次轮询操作，还有两种场景会让没有提交的事务的 redo log 写入到磁盘中。</p>
<ol>
<li>**redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。**注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。</li>
<li><strong>另一种是，并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。</strong></li>
</ol>
<h4 id="io性能瓶颈">IO性能瓶颈</h4>
<ol>
<li>设置 binlog_group_commit_sync_delay 和 binlog_group_commit_sync_no_delay_count 参数，减少 binlog 的写盘次数。这个方法是基于“额外的故意等待”来实现的，因此可能会增加语句的响应时间，但没有丢失数据的风险。</li>
<li>将 sync_binlog 设置为大于 1 的值（比较常见是 100~1000）。这样做的风险是，主机掉电时会丢 binlog 日志。</li>
<li>将 innodb_flush_log_at_trx_commit 设置为 2。这样做的风险是，主机掉电的时候会丢数据。</li>
</ol>
<h3 id="24-mysql是怎么保证主备一致的">24. MySQL是怎么保证主备一致的</h3>
<p>基于binlog</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%885.56.08.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%885.56.08.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%885.56.08.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%885.56.08.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-04-06下午5.56.08.png"
        title="https://img.llc687.top/uPic/截屏2020-04-06下午5.56.08.png" /></p>
<ol>
<li>在备库 B 上通过 change master 命令，设置主库 A 的 IP、端口、用户名、密码，以及要从哪个位置开始请求 binlog，这个位置包含文件名和日志偏移量。</li>
<li>在备库 B 上执行 start slave 命令，这时候备库会启动两个线程，就是图中的 io_thread 和 sql_thread。其中 io_thread 负责与主库建立连接。</li>
<li>主库 A 校验完用户名、密码后，开始按照备库 B 传过来的位置，从本地读取 binlog，发给 B。</li>
<li>备库 B 拿到 binlog 后，写到本地文件，称为中转日志（relay log）。</li>
<li>sql_thread 读取中转日志，解析出日志里的命令，并执行。</li>
</ol>
<h3 id="25-mysql-如何保证高可用">25. Mysql 如何保证高可用</h3>
<p>MySQL 高可用系统的基础，就是主备切换逻辑。</p>
<p>主备延迟的来源</p>
<ul>
<li><strong>备库所在机器的性能要比主库所在的机器性能差</strong></li>
<li><strong>备库的压力大</strong></li>
<li><strong>即大事务</strong></li>
</ul>
<p>切换策略。</p>
<ul>
<li>可靠性优先</li>
<li>可用性优先</li>
</ul>
<p>实际的应用中，更建议使用可靠性优先的策略。毕竟保证数据准确，应该是数据库服务的底线。在这个基础上，通过减少主备延迟，提升系统的可用性。</p>
<h3 id="26-备库为什么延迟几个小时">26. 备库为什么延迟几个小时</h3>
<p>备库并行复制能力。单线程复制能力全面低于多线程复制，对于更新压力较大的主库，备库是可能一直追不上主库的。</p>
<h3 id="27-主库出问题了从库怎么办">27. 主库出问题了，从库怎么办？</h3>
<p>一主多从的切换正确性。</p>
<p>同步位点。</p>
<h3 id="28-读写分离有哪些坑">28. 读写分离有哪些坑？</h3>
<p>过期读：<strong>在从库上会读到系统的一个过期状态</strong></p>
<ul>
<li>部分强制走主库方案；</li>
<li>sleep 方案；</li>
<li>判断主备无延迟方案；</li>
<li>配合 semi-sync 方案；</li>
<li>等主库位点方案；</li>
<li>等 GTID 方案。</li>
</ul>
<h3 id="29丨如何判断一个数据库是不是出问题了">29丨如何判断一个数据库是不是出问题了？</h3>
<ul>
<li>select 1 判断</li>
<li>查表判断</li>
<li>更新判断</li>
<li>内部统计</li>
</ul>
<h3 id="31丨误删数据后除了跑路还能怎么办">31丨误删数据后除了跑路，还能怎么办？</h3>
<h4 id="误删行">误删行</h4>
<p>可以用 Flashback 工具通过闪回把数据恢复回来。</p>
<h4 id="误删库--表">误删库 / 表</h4>
<p>就需要使用全量备份，加增量日志的方式了</p>
<h3 id="32丨为什么还有kill不掉的语句">32丨为什么还有kill不掉的语句？</h3>
<p>这些“kill 不掉”的情况，其实是因为发送 kill 命令的客户端，并没有强行停止目标线程的执行，而只是设置了个状态，并唤醒对应的线程。而被 kill 的线程，需要执行到判断状态的“埋点”，才会开始进入终止逻辑阶段。并且，终止逻辑本身也是需要耗费时间的。</p>
<p>所以，如果发现一个线程处于 Killed 状态，可以做的事情就是，通过影响系统环境，让这个 Killed 状态尽快结束。</p>
<p>比如， InnoDB 并发度的问题，可以临时调大 innodb_thread_concurrency 的值，或停掉别的线程，让出位子给这个线程执行。</p>
<p>而如果是回滚逻辑由于受到 IO 资源限制执行得比较慢，就通过减少系统压力让它加速。</p>
<p>做完这些操作后，其实你已经没有办法再对它做什么了，只能等待流程自己完成。</p>
<h3 id="33丨我查这么多数据会不会把数据库内存打爆">33丨我查这么多数据，会不会把数据库内存打爆？</h3>
<p>由于 MySQL 采用的是边算边发的逻辑，因此对于数据量很大的查询结果来说，不会在 server 端保存完整的结果集。所以，如果客户端读结果不及时，会堵住 MySQL 的查询过程，但是不会把内存打爆。</p>
<p>而对于 InnoDB 引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于 InnoDB 对 LRU 算法做了改进，冷数据的全表扫描，对 Buffer Pool 的影响也能做到可控。</p>
<p>当然，我们前面文章有说过，全表扫描还是比较耗费 IO 资源的，所以业务高峰期还是不能直接在线上主库执行全表扫描的。</p>
<h3 id="34丨到底可不可以使用join">34丨到底可不可以使用join？</h3>
<h4 id="join-的流程">Join 的流程</h4>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%886.43.35.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%886.43.35.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%886.43.35.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-06%e4%b8%8b%e5%8d%886.43.35.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-04-06下午6.43.35.png"
        title="https://img.llc687.top/uPic/截屏2020-04-06下午6.43.35.png" /></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">t1</span> <span class="n">straight_join</span> <span class="n">t2</span> <span class="nf">on</span> <span class="o">(</span><span class="n">t1</span><span class="o">.</span><span class="na">a</span><span class="o">=</span><span class="n">t2</span><span class="o">.</span><span class="na">a</span><span class="o">);</span>																<span class="n">NLJ算法流程图</span>
</code></pre></td></tr></table>
</div>
</div><p>（如果直接使用 join 语句，MySQL 优化器可能会选择表 t1 或 t2 作为驱动表，这样会影响我们分析 SQL 语句的执行过程。）</p>
<ol>
<li>对驱动表 t1 做了全表扫描，这个过程需要扫描 100 行；</li>
<li>而对于每一行 R，根据 a 字段去表 t2 查找，走的是树搜索过程。由于我们构造的数据都是一一对应的，因此每次的搜索过程都只扫描一行，也是总共扫描 100 行；</li>
<li>所以，整个执行流程，总扫描行数是 200。</li>
</ol>
<p>而如果不用 join</p>
<ol>
<li>执行<code>select * from t1</code>，查出表 t1 的所有数据，这里有 100 行；</li>
<li>循环遍历这 100 行数据：
<ul>
<li>从每一行 R 取出字段 a 的值 $R.a；</li>
<li>执行<code>select * from t2 where a=$R.a</code>；</li>
<li>把返回的结果和 R 构成结果集的一行。</li>
</ul>
</li>
</ol>
<p>也是扫描了 200 行，但是总共执行了 101 条语句，比直接 join 多了 100 次交互。</p>
<h4 id="驱动表">驱动表</h4>
<p>驱动表是走全表扫描，而被驱动表是走树搜索。</p>
<ol>
<li>如果是 Index Nested-Loop Join （被驱动表有索引）算法，应该选择小表做驱动表；</li>
<li>如果是 Block Nested-Loop Join 算法：（没索引，将驱动表放入线程内存 join_buffer ，被驱动表一行一行取对比）
<ul>
<li>在 join_buffer_size 足够大的时候，是一样的；</li>
<li>在 join_buffer_size 不够大的时候（这种情况更常见），应该选择小表做驱动表。</li>
</ul>
</li>
</ol>
<p><strong>在决定哪个表做驱动表的时候，应该是两个表按照各自的条件过滤，过滤完成之后，计算参与 join 的各个字段的总数据量，数据量小的那个表，就是“小表”，应该作为驱动表。</strong></p>
<h3 id="35--join语句怎么优化">35 | join语句怎么优化？</h3>
<h4 id="multi-range-read-优化">Multi-Range Read 优化</h4>
<p><strong>因为大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p>
<ol>
<li>据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li>
<li>将 read_rnd_buffer 中的 id 进行递增排序；</li>
<li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li>
</ol>
<p>想稳定地使用 MRR 的话，要设置<code>set optimizer_switch=&quot;mrr_cost_based=off&quot;</code>。（更倾向于不使用 MRR）.<strong>MRR 能够提升性能的核心</strong>在于，查询语句在索引 a 上做的是一个范围查询，得到足够多的主键 id。排序后，再去主键索引查数据，才能体现出“顺序性”的优势。</p>
<h4 id="batched-key-access">Batched Key Access</h4>
<p>BKA 算法的优化要依赖于 MRR，是对 NLJ 算法的优化。把表 t1 的数据取出一部分，放到一个临时内存 join_buffer。</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%884.32.33.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%884.32.33.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%884.32.33.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%884.32.33.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-04-19下午4.32.33.png"
        title="https://img.llc687.top/uPic/截屏2020-04-19下午4.32.33.png" /></p>
<p><strong>大表 join 操作虽然对 IO 有影响，但是在语句执行结束后，对 IO 的影响也就结束了。但是，对 Buffer Pool 的影响就是持续性的，需要依靠后续的查询请求慢慢恢复内存命中率。</strong></p>
<h4 id="bnl-转-bka">BNL 转 BKA</h4>
<p>BNL太耗资源，但如果被驱动表是个大表，但其实实际参与组合的数据很少，建索引的话开销大，不建的话又慢，就可以在查询时创建临时表，把被驱动表的匹配数据放进去再参与join.</p>
<h4 id="hash-join">hash join</h4>
<p>临时表实际中有点扯，这种的话，如果非要不加索引。还是在代码里处理分两次查做映射。</p>
<h3 id="36--为什么临时表可以重名">36 | 为什么临时表可以重名？</h3>
<h4 id="用途">用途</h4>
<p>处理 35 节中的join,分库分表时非分批键查询，可以多表全查询后统一放到某库某实例上，做一个临时的统一表，在进行limit等操作</p>
<h4 id="重名">重名</h4>
<p>创建临时表时创建了一个 frm 文件保存表结构定义，还要有地方保存表数据。</p>
<p><strong>这个 frm 文件放在临时文件目录下，文件名的后缀是.frm，前缀是“#sql{进程 id}<em>{线程 id}</em> 序列号”</strong>。维护数据表，除了物理上有文件外，内存也有套机制区别不同的表，每个表都对应一个 table_def_key。不同session的线程不同所以其实是不重复的。</p>
<h4 id="主从同步">主从同步</h4>
<p>在 binlog_format=&lsquo;row’的时候，临时表的操作不记录到 binlog 中，也省去了不少麻烦，这也可以成为你选择 binlog_format 时的一个考虑因素。</p>
<h3 id="37--什么时候会使用内部临时表">37 | 什么时候会使用内部临时表？</h3>
<p>不论是使用内存临时表还是磁盘临时表，group by 逻辑都需要构造一个带唯一索引的表，执行代价都是比较高的。如果表的数据量比较大，上面这个 group by 语句执行起来就会很慢，</p>
<ol>
<li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li>
<li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li>
<li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li>
<li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li>
</ol>
<h3 id="38都说innodb好那还要不要使用memory引擎">38.都说InnoDB好，那还要不要使用Memory引擎？</h3>
<h4 id="数据组织结构">数据组织结构</h4>
<p>InnoDB 和 Memory 引擎的数据组织方式是不同的：</p>
<ul>
<li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为<strong>索引组织表</strong>（Index Organizied Table）。</li>
<li>而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为<strong>堆组织表</strong>（Heap Organizied Table）</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%885.17.12.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%885.17.12.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%885.17.12.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%885.17.12.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-04-19下午5.17.12.png"
        title="https://img.llc687.top/uPic/截屏2020-04-19下午5.17.12.png" /></p>
<h4 id="hash-索引和-b-tree-索引">hash 索引和 B-Tree 索引</h4>
<p>Memory也可以支持BTree</p>
<h4 id="锁">锁</h4>
<p>内存表不支持行锁，只支持表锁。</p>
<h4 id="持久性">持久性</h4>
<p>重启丢数据，在内存中。</p>
<h3 id="39-自增主键为什么不是连续的">39. 自增主键为什么不是连续的？</h3>
<p><strong>表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。</strong></p>
<ul>
<li>MyISAM 引擎的自增值保存在数据文件中。</li>
<li>InnoDB 自增值，保存内存里，MySQL 8.0 后，才有了“自增值持久化”的能力。之前重启后会去找max(id) + 1，但这是删一个最后的，取到的其实就是重复的了。</li>
</ul>
<h4 id="新插入">新插入</h4>
<p>没有传id就用自增。传了如果大于等于，就更新为传的。</p>
<h4 id="导致不连续">导致不连续</h4>
<ul>
<li>其他的唯一键冲突，未然未插入，但自增值修改是在插入前，即使插入失败也已经更新了。</li>
<li>回滚道理差不多。</li>
<li>批量插入</li>
</ul>
<p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>
<ol>
<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>
<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>
<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>
<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>
</ol>
<p>最后的申请可能就会造成浪费且不连续。</p>
<h3 id="40-insert语句的锁为什么这么多">40.  insert语句的锁为什么这么多？</h3>
<p>insert … select 是很常见的在两个表之间拷贝数据的方法。你需要注意，在可重复读隔离级别下，这个语句会给 select 的表里扫描到的记录和间隙加读锁。</p>
<p>而如果 insert 和 select 的对象是同一个表，则有可能会造成循环写入。这种情况下，我们需要引入用户临时表来做优化。</p>
<p>insert 语句如果出现唯一键冲突，会在冲突的唯一值上加共享的 next-key lock(S 锁)。因此，碰到由于唯一键约束导致报错后，要尽快提交或回滚事务，避免加锁时间过长。</p>
<h3 id="41-怎么最快地复制一张表">41. 怎么最快地复制一张表？</h3>
<h4 id="mysqldump-方法">mysqldump 方法</h4>
<h4 id="导出-csv-文件">导出 CSV 文件</h4>
<h4 id="物理拷贝">物理拷贝</h4>
<p>MySQL 5.6 版本引入了<strong>可传输表空间</strong>(transportable tablespace) 的方法，可通过导出 + 导入表空间的方式，实现物理拷贝表的功能。</p>
<p>假设现在目标是在 db1 库下，复制一个跟表 t 相同的表 r，具体的执行步骤如下：</p>
<ol>
<li>执行 create table r like t，创建一个相同表结构的空表；</li>
<li>执行 alter table r discard tablespace，这时候 r.ibd 文件会被删除；</li>
<li>执行 flush table t for export，这时候 db1 目录下会生成一个 t.cfg 文件；</li>
<li>在 db1 目录下执行 cp t.cfg r.cfg; cp t.ibd r.ibd；这两个命令（这里需要注意的是，拷贝得到的两个文件，MySQL 进程要有读写权限）；</li>
<li>执行 unlock tables，这时候 t.cfg 文件会被删除；</li>
<li>执行 alter table r import tablespace，将这个 r.ibd 文件作为表 r 的新的表空间，由于这个文件的数据内容和 t.ibd 是相同的，所以表 r 中就有了和表 t 相同的数据。</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%885.59.25.png"
        data-srcset="https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%885.59.25.png, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%885.59.25.png 1.5x, https://img.llc687.top/uPic/%e6%88%aa%e5%b1%8f2020-04-19%e4%b8%8b%e5%8d%885.59.25.png 2x"
        data-sizes="auto"
        alt="https://img.llc687.top/uPic/截屏2020-04-19下午5.59.25.png"
        title="https://img.llc687.top/uPic/截屏2020-04-19下午5.59.25.png" /></p>
<p>有以下几个注意点：</p>
<ol>
<li>在第 3 步执行完 flsuh table 命令之后，db1.t 整个表处于只读状态，直到执行 unlock tables 命令后才释放读锁；</li>
<li>在执行 import tablespace 的时候，为了让文件里的表空间 id 和数据字典中的一致，会修改 r.ibd 的表空间 id。而这个表空间 id 存在于每一个数据页中。因此，如果是一个很大的文件（比如 TB 级别），每个数据页都需要修改，所以你会看到这个 import 语句的执行是需要一些时间的。当然，如果是相比于逻辑导入的方法，import 语句的耗时是非常短的。</li>
</ol>
<h3 id="42grant之后要跟着flush-privileges吗">42.grant之后要跟着flush privileges吗？</h3>
<p>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用 grant 和 revoke 语句，是不需要随后加上 flush privileges 语句的。</p>
<p>flush privileges 语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。而这种不一致往往是由于直接用 DML 语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p>
<h3 id="43要不要使用分区表">43.要不要使用分区表？</h3>
<p>略过</p>
<h3 id="45-自增id用完了咋办">45. 自增id用完了咋办</h3>
<ol>
<li>表的自增 id 达到上限后，再申请时它的值就不会改变，进而导致继续插入数据时报主键冲突的错误。</li>
<li>row_id 达到上限后，则会归 0 再重新递增，如果出现相同的 row_id，后写的数据会覆盖之前的数据。</li>
<li>Xid 只需要不在同一个 binlog 文件中出现重复值即可。虽然理论上会出现重复值，但是概率极小，可以忽略不计。</li>
<li>InnoDB 的 max_trx_id 递增值每次 MySQL 重启都会被保存起来，所以我们文章中提到的脏读的例子就是一个必现的 bug，好在留给我们的时间还很充裕。</li>
<li>thread_id 是我们使用中最常见的，而且也是处理得最好的一个自增 id 逻辑了。</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-02-28</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/" data-title="MySQL实战45讲" data-hashtags="MySQL,数据库"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/" data-hashtag="MySQL"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/" data-title="MySQL实战45讲"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 百度" data-sharer="baidu" data-url="https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/" data-title="MySQL实战45讲"><i data-svg-src="/lib/simple-icons/icons/baidu.min.svg"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/" data-title="MySQL实战45讲"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/mysql/">MySQL</a>,&nbsp;<a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/" class="prev" rel="prev" title="分布式事务方案"><i class="fas fa-angle-left fa-fw"></i>分布式事务方案</a></div>
</div>
<div id="comments"><div id="utterances"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://utteranc.es/">Utterances</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.81.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2018 - 2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="/" target="_blank">lyf687</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=Array.prototype.fill%2CArray.prototype.find%2CArray.from%2CIntersectionObserver%2CMath.sign%2CObject.assign%2CPromise%2CObject.entries%2CElement.prototype.closest%2CrequestAnimationFrame%2CCustomEvent%2Chtml5shiv%2CObject.values%2Cfetch%2CElement.prototype.after"></script><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/autocomplete/autocomplete.min.js"></script><script type="text/javascript" src="/lib/algoliasearch/algoliasearch-lite.umd.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/twemoji/twemoji.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/typeit/typeit.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":10},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"","lightTheme":"github-light","repo":"liyifan687/comments"}},"data":{"id-1":"无名鼠辈","id-2":"无名鼠辈"},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false},"search":{"algoliaAppID":"","algoliaIndex":"","algoliaSearchKey":"","highlightTag":"em","maxResultLength":10,"noResultsFound":"没有找到结果","snippetLength":50,"type":"algolia"},"twemoji":true,"typeit":{"cursorChar":"|","cursorSpeed":1000,"data":{"id-1":["id-1"],"id-2":["id-2"]},"duration":-1,"speed":100}};</script><script type="text/javascript" src="/js/theme.min.js"></script><script type="text/javascript">
            window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());
            gtag('config', '014783502852757998779:nk1fvw21g2i', { 'anonymize_ip': true });
        </script><script type="text/javascript" src="https://www.googletagmanager.com/gtag/js?id=014783502852757998779:nk1fvw21g2i" async></script></body>
</html>
