<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>所有文章 - 无名鼠辈</title>
        <link>https://llc687.top/posts/</link>
        <description>所有文章 | 无名鼠辈</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 21 Mar 2021 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://llc687.top/posts/" rel="self" type="application/rss+xml" /><item>
    <title>MySQL 如何实现 ACID ?</title>
    <link>https://llc687.top/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9A%84acid/</link>
    <pubDate>Sun, 21 Mar 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E7%9A%84acid/</guid>
    <description><![CDATA[写在前面 本文主要探讨MySQL InnoDB 引擎下ACID的实现原理，对于诸如什么是事务，隔离级别的含义等基础知识不做过多阐述。 ACID MySQL 作为一个关系型数据库]]></description>
</item><item>
    <title>MySQL实战45讲</title>
    <link>https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/</link>
    <pubDate>Sun, 28 Feb 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E6%9E%B6%E6%9E%84/mysql45%E8%AE%B2/</guid>
    <description><![CDATA[MySQL45讲 1. 一条SQL查询语句怎么运行的 但是大多数情况下我会建议你不要使用查询缓存，为什么呢？因为查询缓存往往弊大于利。 查询缓存的失效]]></description>
</item><item>
    <title>分布式事务方案</title>
    <link>https://llc687.top/posts/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/</link>
    <pubDate>Sun, 28 Feb 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/</guid>
    <description><![CDATA[分布式事务方案 XA/二阶段提交 基于XA协议的二阶段提交 所谓的 XA 方案，即：两阶段提交，有一个事务管理器的概念，负责协调多个数据库（资源管理器）]]></description>
</item><item>
    <title>微服务架构体系</title>
    <link>https://llc687.top/posts/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/</link>
    <pubDate>Sun, 28 Feb 2021 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E6%9E%B6%E6%9E%84/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/</guid>
    <description><![CDATA[微服务架构体系 前段内部听了下分享 Service Mesh。做一些总结 架构的演进 这种东西有点信雅达，没什么绝对标准 单体应用：在第一阶段的单体应用很好理解。 垂]]></description>
</item><item>
    <title>从 SpringApplication.run 开始</title>
    <link>https://llc687.top/posts/java/%E4%BB%8E-springapplication.run-%E5%BC%80%E5%A7%8B/</link>
    <pubDate>Sun, 18 Oct 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/java/%E4%BB%8E-springapplication.run-%E5%BC%80%E5%A7%8B/</guid>
    <description><![CDATA[从 SpringApplication.run 开始 这是你的 SpringBoot ，启动，只需一键。 1 2 3 4 5 6 @SpringBootApplication public class ServerApplication { public static void main(String[] args) { SpringApplication.run(ServerApplication.class,args); } } 但这一键背后发生了什么？ 挂着嘴边的 IOC 容器何时诞生，天天见的 @Au]]></description>
</item><item>
    <title>中介者模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[中介者模式 目的 集中相关对象之间复杂的沟通和控制方式。 类图 角色 Mediator: 抽象中介者 ConcreteMediator: 具体中介者 Colleague: 抽象同事类 ConcreteColleague: 具体同事类 实现 这个模式的现实案例最常见就是]]></description>
</item><item>
    <title>备忘录模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[备忘录模式 目的 在不违反封装的情况下获得对象的内部状态，在需要时可以将对象恢复到最初状态。 类图 角色 Originator: 原始对象，发起人。 Caretaker: 管理角色，负责保存好备]]></description>
</item><item>
    <title>观察者模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[观察者模式 目的 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且做出反应。 发生改变的对象称为观察目标，而被通知的对]]></description>
</item><item>
    <title>解释器模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[解释器模式 目的 为语言创建解释器，通常由语言的语法和语法分析来定义。 类图 角色 AbstractExpression 抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类]]></description>
</item><item>
    <title>访问者模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[访问者模式 目的 为一个对象结构(比如组合结构)增加新能力。 类图 角色 Visitor: 访问者。为每一个 ConcreteElement 声明一个 visit 操作 ConcreteVisitor: 具体访问者。存储遍历过程中的累计结果 ObjectStructure: 对]]></description>
</item></channel>
</rss>
