<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Java - 标签 - 无名鼠辈</title>
        <link>https://llc687.top/tags/java/</link>
        <description>Java - 标签 - 无名鼠辈</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://llc687.top/tags/java/" rel="self" type="application/rss+xml" /><item>
    <title>中介者模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[中介者模式 目的 集中相关对象之间复杂的沟通和控制方式。 类图 角色 Mediator: 抽象中介者 ConcreteMediator: 具体中介者 Colleague: 抽象同事类 ConcreteColleague: 具体同事类 实现 这个模式的现实案例最常见就是]]></description>
</item><item>
    <title>备忘录模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[备忘录模式 目的 在不违反封装的情况下获得对象的内部状态，在需要时可以将对象恢复到最初状态。 类图 角色 Originator: 原始对象，发起人。 Caretaker: 管理角色，负责保存好备]]></description>
</item><item>
    <title>观察者模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[观察者模式 目的 定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且做出反应。 发生改变的对象称为观察目标，而被通知的对]]></description>
</item><item>
    <title>解释器模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[解释器模式 目的 为语言创建解释器，通常由语言的语法和语法分析来定义。 类图 角色 AbstractExpression 抽象解释器：声明一个所有具体表达式都要实现的抽象接口（或者抽象类]]></description>
</item><item>
    <title>访问者模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[访问者模式 目的 为一个对象结构(比如组合结构)增加新能力。 类图 角色 Visitor: 访问者。为每一个 ConcreteElement 声明一个 visit 操作 ConcreteVisitor: 具体访问者。存储遍历过程中的累计结果 ObjectStructure: 对]]></description>
</item><item>
    <title>迭代器模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 12 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[迭代器模式 目的 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。 类图 角色 Aggregate 聚合类，其中 createIterator() 方法可以产生一个 Iterator； ConcreteAggregate]]></description>
</item><item>
    <title>命令</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 05 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[命令模式 目的 将命令(请求)封装在对象中，以便使用命令来参数化其它对象，或将命令对象放入队列中排队，或将命令对象的操作记录到日志中，以及支持可]]></description>
</item><item>
    <title>模板方法</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</link>
    <pubDate>Sun, 05 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/</guid>
    <description><![CDATA[模板方法 目的 定义算法框架，并将一些步骤的实现延迟到子类。 通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。 类图 角色 Abst]]></description>
</item><item>
    <title>状态模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 05 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[状态模式 目的 允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。其别名为状态对象(Objects for States)，状态模式]]></description>
</item><item>
    <title>策略模式</title>
    <link>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
    <pubDate>Sun, 05 Jul 2020 00:00:00 &#43;0000</pubDate>
    <author>作者</author>
    <guid>https://llc687.top/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
    <description><![CDATA[策略模式 目的 定义一系列算法，封装每个算法，并使它们可以互换。可以让算法独立于使用它的客户端。 类图 角色 Context: 环境类 Strategy: 抽象策略类 ConcreteStrategy: 具体策略类 实现 抽象]]></description>
</item></channel>
</rss>
